"""Lyapunov Actor-Critic algorithm

This module contains a pytorch implementation of the LAC algorithm of
`Han et al. 2020 <http://arxiv.org/abs/2004.14288>`_. The ``use_lyapunov`` input
argument can be used to disable the Lyapunov behavior. When this is done you end up
with the Soft Actor Critic algorithm of
`Haarnoja et al. 2019 <https://arxiv.org/abs/1812.05905>`_

.. note::
    Code Conventions:
        - We use a `_` suffix to distinguish the next state from the current state.
        - We use a2 to specify an action that was generated by the Gaussian actor.
        - When in the comments an equation (eq.) is specified without a prefix this
            regards an equation in Han et. al 2019.
"""

import argparse
import glob
import itertools
import os
import os.path as osp
import random
import sys
import time
from collections import OrderedDict
from copy import deepcopy

import gym
import numpy as np
import torch
import torch.nn as nn
from machine_learning_control.control.algos.pytorch.common import get_lr_scheduler
from machine_learning_control.control.algos.pytorch.common.buffers import ReplayBuffer
from machine_learning_control.control.algos.pytorch.common.helpers import (
    count_vars,
    retrieve_device,
)
from machine_learning_control.control.algos.pytorch.policies import (
    LyapunovActorCritic,
    SoftActorCritic,
)
from machine_learning_control.control.common.helpers import heuristic_target_entropy
from machine_learning_control.control.utils import safe_eval
from machine_learning_control.control.utils.eval_utils import test_agent
from machine_learning_control.control.utils.gym_utils import (
    is_discrete_space,
    is_gym_env,
)
from machine_learning_control.control.utils.log_utils import EpochLogger, colorize
from machine_learning_control.control.utils.run_utils import setup_logger_kwargs
from torch.optim import Adam

# Script settings
SCALE_LAMBDA_MIN_MAX = (
    0.0,
    1.0,
)  # Range of lambda lagrance multiplier
SCALE_ALPHA_MIN_MAX = (0.0, np.inf)  # Range of alpha lagrance multiplier
STD_OUT_LOG_VARS_DEFAULT = [
    "Epoch",
    "TotalEnvInteracts",
    "AverageEpRet",
    "AverageTestEpRet",
    "AverageEpLen",
    "AverageTestEpLen",
    "AverageAlpha",
    "AverageLambda",
    "AverageLossAlpha",
    "AverageLossLambda",
    "AverageLossPi",
    "AverageEntropy",
]


class LAC(object):
    """The Lyapunov actor critic algorithm.

    Attributes:
        ac (torch.nn.module): The (lyapunov) actor critic module.
        ac_ (torch.nn.module): The (lyapunov) target actor critic module.
        log_alpha (torch.Tensor): The temperature lagrance multiplier.
        log_labda (torch.Tensor): The Lyapunov lagrance multiplier.
        target_entropy (int): The target entropy.
        device (str): The device the networks are placed on (CPU or GPU).
        use_lyapunov (bool): Whether the Lyapunov Critic is used (use_lyapunov=True) or
            the regular Q-critic (use_lyapunov=false).
    """

    def __init__(
        self,
        env,
        actor_critic=None,
        ac_kwargs=dict(
            hidden_sizes={"actor": [64] * 2, "critic": [128] * 2},
            activation=nn.ReLU,
            output_activation={"actor": nn.ReLU},
        ),
        use_lyapunov=True,
        opt_type="minimize",
        alpha=0.99,
        alpha3=0.2,
        labda=0.99,
        gamma=0.9,
        polyak=0.995,
        target_entropy=None,
        adaptive_temperature=True,
        lr_a=1e-4,
        lr_c=3e-4,
        device="cpu",
    ):
        """Lyapunov (soft) Actor-Critic (LAC)

        Args:
            env (gym.env): The gym environment the LAC is training in. This is used to
                retrieve the activation and observation space dimensions. This is used
                while creating the network sizes. The environment must satisfy the
                OpenAI Gym API.
            actor_critic (torch.nn.Module, optional): The constructor method for a
                PyTorch Module with an ``act`` method, a ``pi`` module, a ``Q1`` module,
                a ``Q2``module and a ``L`` module. The ``act`` method and ``pi`` module
                should accept batches of observations as inputs, and ``Q1``, ``Q2`` and
                ``L`` should accept a batch of observations and a batch of actions as
                inputs. When called, ``act``, ``q1``, and ``q2`` should return:

                ===========  ================  ======================================
                Call         Output Shape      Description
                ===========  ================  ======================================
                ``act``      (batch, act_dim)  | Numpy array of actions for each
                                            | observation.
                ``Q1``       (batch,)          | Tensor containing one current estimate
                                            | of Q* for the provided observations
                                            | and actions. (Critical: make sure to
                                            | flatten this!)
                ``Q2``       (batch,)          | Tensor containing the other current
                                            | estimate of Q* for the provided
                                            | observations and actions. (Critical:
                                            | make sure to flatten this!)
                ``L``       (batch,)          | Tensor containing the other current
                                            | estimate of L* for the provided
                                            | observations and actions. (Critical:
                                            | make sure to flatten this!)
                ===========  ================  ======================================

                Calling ``pi`` should return:

                ===========  ================  ======================================
                Symbol       Shape             Description
                ===========  ================  ======================================
                ``a``        (batch, act_dim)  | Tensor containing actions from policy
                                            | given observations.
                ``logp_pi``  (batch,)          | Tensor containing log probabilities of
                                            | actions in ``a``. Importantly: gradients
                                            | should be able to flow back into ``a``.
                ===========  ================  ======================================

                Defaults to `:class:LyapunovActorCritic` if ``use_lyapunov=True``
                else `:class:SoftActorCritic`.
            ac_kwargs (dict, optional): Any kwargs appropriate for the ActorCritic
                object you provided to LAC. Defaults to:

                ====================  ===============================================
                kwarg                 Value
                ====================  ===============================================
                hidden_sizes_actor    64 x 2
                hidden_sizes_critic   128 x 2
                activation            nn.ReLU
                output_activation     nn.ReLU
                ====================  ===============================================
            use_lyapunov (bool, optional): Whether the Lyapunov Critic is used
                (use_lyapunov=True) or the regular Q-critic (use_lyapunov=false).
                Defaults to ``True``.
            opt_type (str, optional): The optimization type you want to use. Options
                "maximize" and "minimize". Defaults to maximize.
            alpha (float, optional): Entropy regularization coefficient (Equivalent to
                inverse of reward scale in the original SAC paper). Defaults to
                ``0.99``.
            alpha3 (float, optional): The Lyapunov constraint error boundary. Defaults
                to ``0.2``.
            labda (float, optional): The Lyapunov lagrance multiplier. Defaults to
                ``0.99``.
            gamma (float, optional): Discount factor. (Always between 0 and 1.).
                Defaults to ``0.9``.
            polyak (float, optional): Interpolation factor in polyak averaging for
                target networks. Target networks are updated towards main networks
                according to:

                .. math:: \\theta_{\\text{targ}} \\leftarrow
                    \\rho \\theta_{\\text{targ}} + (1-\\rho) \\theta

                where :math:`\\rho` is polyak. (Always between 0 and 1, usually
                close to 1.). Defaults to ``0.995``.
            target_entropy (float, optional): Initial target entropy used while learning
                the entropy temperature (alpha). Defaults to the
                maximum information (bits) contained in action space. This can be
                calculated according to :

                .. math::
                    -{\\prod }_{i=0}^{n}action\\_di{m}_{i}\\phantom{\\rule{0ex}{0ex}}
            adaptive_temperature (bool, optional): Enabled Automating Entropy Adjustment
                for maximum Entropy RL_learning.
            lr_a (float, optional): Learning rate used for the actor. Defaults to
                ``1e-4``.
            lr_c (float, optional): Learning rate used for the (lyapunov) critic.
                Defaults to ``1e-4``.
            device (str, optional): The device the networks are placed on (cpu or gpu).
                Defaults to "cpu".
        """
        # Validate gym env
        # NOTE (rickstaa): The current implementation only works with continuous spaces.
        if not is_gym_env(env):
            raise ValueError("Env must be a valid Gym environment.")
        if is_discrete_space(env.action_space) or is_discrete_space(
            env.observation_space
        ):
            raise NotImplementedError(
                "The LAC algorithm does not yet support discrete observation/action "
                "spaces. Please open a feature/pull request on "
                "https://github.com/rickstaa/machine-learning-control/issues to "
                "if you need this."
            )

        print(
            colorize(
                "INFO: You are using the {} environment.".format(env.unwrapped.spec.id),
                "green",
                bold=True,
            )
        )
        if use_lyapunov:
            print(
                colorize("INFO: You are using the LAC algorithm.", "green", bold=True)
            )
        else:
            print(
                colorize("INFO: You are using the ", "green", bold=True)
                + colorize("SAC", "yellow", bold=True)
                + colorize(" algorithm.", "green", bold=True)
            )

        # Store algorithm parameters
        self._device = retrieve_device(device)
        self._use_lyapunov = use_lyapunov
        self._adaptive_temperature = adaptive_temperature
        self._opt_type = opt_type
        self._polyak = polyak
        self._gamma = gamma
        self._alpha3 = alpha3
        self._lr_a = lr_a
        if self._use_lyapunov:
            self._lr_lag = lr_a
        self._lr_c = lr_c
        if not isinstance(target_entropy, (float, int)):
            self._target_entropy = heuristic_target_entropy(env.action_space)
        else:
            self._target_entropy = target_entropy

        # Create variables for the Lagrance multipliers
        # NOTE (rickstaa): Clip at 1e-37 to prevent log_alpha/log_lambda from becoming
        # -np.inf
        self.log_alpha = torch.tensor(
            np.log(1e-37 if alpha < 1e-37 else alpha), requires_grad=True
        )
        self.log_alpha.requires_grad = True
        if self._use_lyapunov:
            self.log_labda = torch.tensor(
                np.log(1e-37 if labda < 1e-37 else labda), requires_grad=True
            )
            self.log_labda.requires_grad = True

        # Get default actor critic if no 'actor_critic' was supplied
        if actor_critic is None:
            actor_critic = LyapunovActorCritic if use_lyapunov else SoftActorCritic

        # Create actor-critic module and target networks
        # NOTE (rickstaa): Pytorch currently uses kaiming initialization for the baises
        # in the future this will change to zero initialization
        # (https://github.com/pytorch/pytorch/issues/18182). This however does not
        # influence the results.
        # Create actor-critic module and target networks
        self.ac = actor_critic(env.observation_space, env.action_space, **ac_kwargs).to(
            self._device
        )
        self.ac_targ = deepcopy(self.ac).to(self._device)

        # Freeze target networks with respect to optimizers (updates via polyak avg.)
        for p in self.ac_targ.parameters():
            p.requires_grad = False

        # Create optimizers
        # NOTE (rickstaa): We here optimize for log_alpha and log_labda instead of
        # alpha and labda because it is more numerically stable (see:
        # https://github.com/rail-berkeley/softlearning/issues/136)
        # NOTE (rickstaa): The parameters() method returns a generator. This generator
        # becomes empty after you looped through all values. As a result, below we use a
        # lambda function to keep referencing the actual model parameters.
        self._pi_optimizer = Adam(self.ac.pi.parameters(), lr=self._lr_a)
        self._pi_params = lambda: self.ac.pi.parameters()
        if self._adaptive_temperature:
            self._log_alpha_optimizer = Adam([self.log_alpha], lr=self._lr_a)
        if self._use_lyapunov:
            self._log_labda_optimizer = Adam([self.log_labda], lr=self._lr_lag)
            self._c_params = lambda: self.ac.L.parameters()
            self._c_optimizer = Adam(self._c_params(), lr=self._lr_c)
        else:
            # List of parameters for both Q-networks (save this for convenience)
            self._c_params = lambda: itertools.chain(
                *[gen() for gen in [self.ac.Q1.parameters, self.ac.Q2.parameters]]
            )
            self._c_optimizer = Adam(self._c_params, lr=self._lr_c)

    def get_action(self, s, deterministic=False):
        """Returns the current action of the policy.

        Args:
            s (np.numpy): The current state.
            deterministic (bool, optional): Whether to return a deterministic action.
                Defaults to ``False``.

        Returns:
            np.numpy: The current action.
        """
        return self.ac.act(
            torch.as_tensor(s, dtype=torch.float32).to(self._device), deterministic
        )

    def update(self, data):
        """Update the actor critic network using stochastic gradient descent.

        Args:
            data (dict): Dictionary containing a batch of experiences.
        """
        diagnostics = dict()
        o, a, r, o_, d = (
            data["obs"],
            data["act"],
            data["rew"],
            data["obs_next"],
            data["done"],
        )
        ################################################
        # Optimize (Lyapunov/Q) critic #################
        ################################################
        self._c_optimizer.zero_grad()
        if self.use_lyapunov:

            # Get target Lyapunov value (Bellman-backup)
            with torch.no_grad():
                a2_, _ = self.ac_targ.pi(
                    o_
                )  # NOTE (rickstaa): Target actions come from *current* *target* policy
                l_pi_targ = self.ac_targ.L(o_, a2_)
                l_backup = (
                    r + self._gamma * (1 - d) * l_pi_targ.detach()
                )  # The Lyapunov candidate

            # Get current Lyapunov value
            l1 = self.ac.L(o, a)

            # Calculate Lyapunov *CRITIC* error
            # NOTE (rickstaa): The 0.5 multiplication factor was added to make the
            # derivation cleaner and can be safely removed without influencing the
            # minimization. We kept it here for consistency.
            # NOTE (rickstaa): I use a manual implementation instead of using
            # F.mse_loss as this is 2 times faster. This can be changed back to
            # F.mse_loss if Torchscript is used.
            l_error = 0.5 * ((l1 - l_backup) ** 2).mean()  # See eq. 7

            l_error.backward()
            self._c_optimizer.step()

            # Store diagnostics
            l_info = dict(LVals=l1.detach().numpy())
            diagnostics.update({**l_info, "ErrorL": l_error.detach().numpy()})
        else:

            # Retrieve the current Q values
            q1 = self.ac.Q1(o, a)
            q2 = self.ac.Q2(o, a)

            # Get target Q values (Bellman-backup)
            # NOTE (rickstaa): Here we use max-clipping instead of min-clipping used
            # in the SAC algorithm since we want to minimize the return.
            with torch.no_grad():
                a2, logp_a2 = self.ac.pi(
                    o_
                )  # NOTE (rickstaa): Target actions coming from *current* policy

                # Get target Q values based on optimization type
                q1_pi_targ = self.ac_targ.Q1(o_, a2)
                q2_pi_targ = self.ac_targ.Q2(o_, a2)
                if self._opt_type.lower() == "minimize":
                    q_pi_targ = torch.max(
                        q1_pi_targ, q2_pi_targ,
                    )  # Use max clipping  to prevent overestimation bias.
                else:
                    q_pi_targ = torch.min(
                        q1_pi_targ, q2_pi_targ
                    )  # Use min clipping to prevent overestimation bias
                q_backup = r + self._gamma * (1 - d) * (
                    q_pi_targ - self.alpha * logp_a2
                )

            # Calculate Q-critic MSE loss against Bellman backup
            loss_q1 = 0.5 * ((q1 - q_backup) ** 2).mean()  # See Haarnoja eq. 5
            loss_q2 = 0.5 * ((q2 - q_backup) ** 2).mean()
            loss_q = loss_q1 + loss_q2

            loss_q.backward()
            self._c_optimizer.step()

            # Store diagnostics
            q_info = dict(Q1Vals=q1.detach().numpy(), Q2Vals=q2.detach().numpy())
            diagnostics.update({**q_info, "LossQ": loss_q.detach().numpy()})
        ################################################
        # Optimize Gaussian actor ######################
        ################################################
        self._pi_optimizer.zero_grad()

        # Freeze Q-networks so you don't waste computational effort
        # computing gradients for them during the policy learning step.
        for p in self._c_params():
            p.requires_grad = False

        # Retrieve log probabilities of batch observations based on *current* policy
        pi, logp_pi = self.ac.pi(o)

        # Calculate entropy-regularized policy loss
        if self.use_lyapunov:

            # Get target lyapunov value
            a2, _ = self.ac.pi(
                o_
            )  # NOTE (rickstaa): Target actions come from *current* policy
            lya_l_ = self.ac.L(o_, a2)

            # Compute Lyapunov Actor error
            l_delta = torch.mean(lya_l_ - l1.detach() + self._alpha3 * r)  # See eq. 11

            a_loss = (
                self.labda.detach() * l_delta + self.alpha.detach() * logp_pi.mean()
            )  # See eq. 12
        else:
            # Retrieve the current Q values for the action given by the current policy
            # NOTE (rickstaa): Actions come from *current* policy
            q1_pi = self.ac.Q1(o, pi)
            q2_pi = self.ac.Q2(o, pi)
            if self._opt_type.lower() == "minimize":
                q_pi = torch.max(q1_pi, q2_pi)
            else:
                q_pi = torch.min(q1_pi, q2_pi)

            a_loss = (self.alpha.detach() * logp_pi - q_pi).mean()  # See Haarnoja eq. 7

        a_loss.backward()
        self._pi_optimizer.step()

        # Store diagnostics
        pi_info = dict(
            LogPi=logp_pi.detach().numpy(),
            Entropy=-torch.mean(logp_pi).detach().numpy(),
        )  # FIXME: Make GPU compatibel .cpu().detach()
        diagnostics.update({**pi_info, "LossPi": a_loss.detach().numpy()})
        ################################################
        # Optimize alpha (Entropy temperature) #########
        ################################################

        # Freeze Pi-networks so you don't waste computational effort
        # computing gradients for them during the policy learning step.
        for p in self._pi_params():
            p.requires_grad = False

        if self._adaptive_temperature:
            self._log_alpha_optimizer.zero_grad()

            # Calculate alpha loss
            alpha_loss = -(
                self.alpha * (logp_pi + self.target_entropy).detach()
            ).mean()  # See Haarnoja eq. 17

            alpha_loss.backward()
            self._log_alpha_optimizer.step()

            # Store diagnostics
            alpha_info = dict(Alpha=self.alpha.detach().numpy())
            diagnostics.update({**alpha_info, "LossAlpha": alpha_loss.detach().numpy()})
        ################################################
        # Optimize labda (Lyapunov temperature) ########
        ################################################
        if self.use_lyapunov:
            self._log_labda_optimizer.zero_grad()

            # Calculate labda loss
            # NOTE (rickstaa): Log_labda was used in the lambda_loss function because
            # using lambda caused the gradients to vanish. This is caused since we
            # restrict lambda within a 0-1.0 range using the clamp function (see #38).
            # Using log_lambda also is more numerically stable.
            labda_loss = -(
                self.log_labda * l_delta.detach()
            ).mean()  # See formulas under eq. 14

            labda_loss.backward()
            self._log_labda_optimizer.step()

            # Store diagnostics
            labda_info = dict(Lambda=self.labda.detach().numpy())
            diagnostics.update(
                {**labda_info, "LossLambda": labda_loss.detach().numpy()}
            )

        # Unfreeze Pi and Q networks so you can optimize it at next SGD step.
        for p in self._c_params():
            p.requires_grad = True
        for p in self._pi_params():
            p.requires_grad = True

        ################################################
        # Update target networks and return ############
        # diagnostics. #################################
        ################################################
        self._update_targets()
        return diagnostics

    def save(self, path, save=True):
        """Can be used to save the current model state.

        Args:
            path (str): The path where you want to save the policy.
            save (bool): Whether you want to save the model to disk. Usefull for when
                you only want to retrieve the model state dictionary (ie. when you want
                to save it using the logger). Defaults to 'True'.
        """

        model_state_dict = self.state_dict()

        if save:
            save_path = osp.join(path, "policy/model.pt")
            if osp.exists(osp.dirname(save_path)):
                print(
                    colorize(
                        (
                            "WARN: Log dir %s already exists! Storing policy there "
                            "anyway." % osp.dirname(save_path)
                        ),
                        "red",
                        bold=True,
                    )
                )
            else:
                os.makedirs(osp.dirname(save_path))
            torch.save(model_state_dict, save_path)
            print(
                colorize(f"INFO: Saved policy to path: {save_path}", "cyan", bold=True)
            )

        return model_state_dict

    def restore(self, path, restore_lagrance_multipliers=False):
        """Restores a already trained policy. Used for transfer learning.

        Args:
            path (str): The path where the model 'state_dict' of the policy is found.
            restore_lagrance_multipliers (bool, optional): Whether you want to restore
                the lagrance multipliers. By fault ``False``.

        Raises:
            Exception: Raises an exception if something goes wrong during loading.
        """

        if os.path.basename(path) != ["model.pt", "model.pth"]:
            load_path = glob.glob(path + "/**/model_state.pt*", recursive=True)
            if len(load_path) == 0:
                model_path = glob.glob(path + "/**/model.pt*", recursive=True)
                if len(model_path) > 1:
                    raise Exception(
                        f"Only whole pickled models found in '{path}'. Using whole "
                        "pickled models as a starting point is currently not supported "
                        "as this method of loading is discouraged by the pytorch "
                        "documentation. Please supply a path that contains a "
                        "'model_state' dictionary and try again."
                    )
                else:
                    raise Exception(
                        f"No models found in '{path}'. Please check your policy restore"
                        "path and try again."
                    )
            elif len(load_path) > 1:
                raise Exception(
                    f"Multiple models found in path '{path}'. Please check your policy "
                    "restore path and try again."
                )

        restored_model_state_dict = torch.load(load_path[0])
        self.load_state_dict(restored_model_state_dict, restore_lagrance_multipliers)

    def state_dict(self):
        """Returns a dictionary containing a whole state of the module.

        Returns:
            dict: A dictionary containing a whole state of the module.
        """
        lagrance_multipliers = [("alpha", self.alpha.detach())]
        lagrance_multipliers.append(
            ("labda", self.labda.detach())
        ) if self.use_lyapunov else None

        return OrderedDict(
            [
                ("class_name", "LAC" if self._use_lyapunov else "SAC"),
                ("_use_lyapunov", self._use_lyapunov),
                ("ac", self.ac.state_dict()),
                ("ac_targ", self.ac_targ.state_dict()),
                *lagrance_multipliers,
            ]
        )

    def load_state_dict(self, state_dict, restore_lagrance_multipliers=True):
        """Copies parameters and buffers from :attr:`state_dict` into
        this module and its descendants.

        Args:
            state_dict (dict): a dict containing parameters and
                persistent buffers.
            restore_lagrance_multipliers (bool, optional): Whether you want to restore
                the lagrance multipliers. By fault ``True``.
        """

        # Validate if right state_dictionary is given
        if self.state_dict().keys() != state_dict.keys():
            raise ValueError(
                "The 'state_dict' you tried to load does not seem to be right. It "
                "contains the {} keys while the {} keys are expected ".format(
                    list(state_dict.keys()), list(self.state_dict().keys())
                )
                + "for the '{}' model.".format(self.__class__.__name__)
            )

        for name, param in state_dict.items():
            if hasattr(self, name):
                if hasattr(getattr(self, name), "load_state_dict"):
                    getattr(self, name).load_state_dict(param)
                else:
                    if (
                        restore_lagrance_multipliers
                        or not restore_lagrance_multipliers
                        and name not in ["labda", "alpha"]
                    ):
                        setattr(self, name, param)
            else:
                if name != "class_name":
                    raise AttributeError(
                        "Can't load parameter '{}' onto the '{}' policy since ".format(
                            name, self.__class__.__name__
                        )
                        + "it does not exist. If this issue persists Please open a "
                        "issue on"
                        "https://github.com/rickstaa/machine-learning-control/issues "
                        "if this issue persits."
                    )

    def _update_targets(self):
        """Updates the target networks based on a Exponential moving average
        (Polyak averaging).
        """
        with torch.no_grad():
            for p, p_targ in zip(self.ac.parameters(), self.ac_targ.parameters()):
                # NOTE: We use an in-place operations "mul_", "add_" to update target
                # params, as opposed to "mul" and "add", which would make new tensors.
                p_targ.data.mul_(self._polyak)
                p_targ.data.add_((1 - self._polyak) * p.data)

    @property
    def alpha(self):
        """Property used to clip alpha to be equal or bigger than 0.0 to prevent it from
        becoming nan when log_alpha becomes -inf. For alpha no upper bound is used.
        """
        return torch.clamp(self.log_alpha.exp(), *SCALE_ALPHA_MIN_MAX)

    @alpha.setter
    def alpha(self, set_val):
        """Property used to make sure alpha and log_alpha are related."""
        self.log_alpha.data = np.log(
            1e-37
            if torch.as_tensor(set_val, dtype=self.log_alpha.dtype) < 1e-37
            else set_val
        )

    @property
    def labda(self):
        """Property used to clip lambda to be equal or bigger than 0.0 in order to
        prevent it from becoming nan when log_labda becomes -inf. Further we clip it to
        be lower or equal than 1.0 in order to prevent lambda from exploding when the
        the hyperparameters are chosen badly.
        """
        return torch.clamp(self.log_labda.exp(), *SCALE_LAMBDA_MIN_MAX)

    @labda.setter
    def labda(self, set_val):
        """Property used to make sure labda and log_labda are related."""
        self.log_labda.data = np.log(
            1e-37
            if torch.as_tensor(set_val, dtype=self.log_labda.dtype) < 1e-37
            else set_val
        )

    @property
    def target_entropy(self):
        return self._target_entropy

    @target_entropy.setter
    def target_entropy(self, set_val):
        error_msg = (
            "Changing the 'target_entropy' during training is not allowed."
            "Please open a feature/pull request on "
            "https://github.com/rickstaa/machine-learning-control/issues to "
            "if you need this."
        )
        raise AttributeError(error_msg)

    @property
    def use_lyapunov(self):
        return self._use_lyapunov

    @use_lyapunov.setter
    def use_lyapunov(self, set_val):
        error_msg = (
            "WARN: Changing the 'use_lyapunov' value during training is not allowed."
            "Please open a feature/pull request on "
            "https://github.com/rickstaa/machine-learning-control/issues to "
            "if you need this."
        )
        raise AttributeError(error_msg)


def validate_args(**kwargs):
    """Checks if the input argument have valid values.

    Raises:
        ValueError: If a value is invalid.
    """
    if kwargs["update_after"] > kwargs["steps_per_epoch"]:
        raise ValueError(
            "You can not set 'update_after' bigger than the 'steps_per_epoch'. Please "
            "change this and try again."
        )


def lac(
    env_fn,
    actor_critic=None,
    ac_kwargs=dict(
        hidden_sizes={"actor": [64] * 2, "critic": [128] * 2},
        activation=nn.ReLU,
        output_activation=nn.ReLU,
    ),
    use_lyapunov=True,
    opt_type="minimize",
    max_ep_len=1000,
    epochs=100,
    steps_per_epoch=2048,
    start_steps=0,
    update_every=100,
    update_after=1000,
    steps_per_update=100,
    num_test_episodes=10,
    alpha=0.99,
    alpha3=0.2,
    labda=0.99,
    gamma=0.9,
    polyak=0.995,
    target_entropy=None,
    adaptive_temperature=True,
    lr_a=1e-4,
    lr_c=3e-4,
    lr_a_final=1e-10,
    lr_c_final=1e-10,
    lr_decay_type="linear",
    batch_size=256,
    replay_size=int(1e6),
    seed=None,
    device="cpu",
    logger_kwargs=dict(),
    save_freq=1,
    start_policy=None,
):
    """Trains the lac algorithm in a given environment.

    Args:
        env_fn: A function which creates a copy of the environment.
            The environment must satisfy the OpenAI Gym API.
        actor_critic (torch.nn.Module, optional): The constructor method for a
            PyTorch Module with an ``act`` method, a ``pi`` module, a ``Q1`` module,
            a ``Q2``module and a ``L`` module. The ``act`` method and ``pi`` module
            should accept batches of observations as inputs, and ``Q1``, ``Q2`` and
            ``L`` should accept a batch of observations and a batch of actions as
            inputs. When called, ``act``, ``q1``, and ``q2`` should return:

            ===========  ================  ======================================
            Call         Output Shape      Description
            ===========  ================  ======================================
            ``act``      (batch, act_dim)  | Numpy array of actions for each
                                        | observation.
            ``Q1``       (batch,)          | Tensor containing one current estimate
                                        | of Q* for the provided observations
                                        | and actions. (Critical: make sure to
                                        | flatten this!)
            ``Q2``       (batch,)          | Tensor containing the other current
                                        | estimate of Q* for the provided
                                        | observations and actions. (Critical:
                                        | make sure to flatten this!)
            ``L``       (batch,)          | Tensor containing the other current
                                        | estimate of L* for the provided
                                        | observations and actions. (Critical:
                                        | make sure to flatten this!)
            ===========  ================  ======================================

            Calling ``pi`` should return:

            ===========  ================  ======================================
            Symbol       Shape             Description
            ===========  ================  ======================================
            ``a``        (batch, act_dim)  | Tensor containing actions from policy
                                        | given observations.
            ``logp_pi``  (batch,)          | Tensor containing log probabilities of
                                        | actions in ``a``. Importantly: gradients
                                        | should be able to flow back into ``a``.
            ===========  ================  ======================================

            Defaults to `:class:LyapunovActorCritic` if ``use_lyapunov=True``
            else `:class:SoftActorCritic`.
        ac_kwargs (dict, optional): Any kwargs appropriate for the ActorCritic
            object you provided to LAC. Defaults to:

            ====================  ===============================================
            kwarg                 Value
            ====================  ===============================================
            hidden_sizes_actor    64 x 2
            hidden_sizes_critic   128 x 2
            activation            nn.ReLU
            output_activation     nn.ReLU
            ====================  ===============================================
        use_lyapunov (bool, optional): Whether the Lyapunov Critic is used
            (use_lyapunov=True) or the regular Q-critic (use_lyapunov=false).
            Defaults to ``True``.
        opt_type (str, optional): The optimization type you want to use. Options
            "maximize" and "minimize". Defaults to minimize.
        max_ep_len (int, optional): Maximum length of trajectory / episode /
            rollout. Defaults to ``500``.
        epochs (int, optional): Number of epochs to run and train agent. Defaults
            to ``100``.
        steps_per_epoch (int, optional): Number of steps of interaction
            (state-action pairs) for the agent and the environment in each epoch.
            Defaults to ``2048``.
        start_steps (int, optional): Number of steps for uniform-random action
            selection, before running real policy. Helps exploration. Defaults to
            ``0``.
        update_every (int, optional): Number of env interactions that should elapse
            between gradient descent updates. Defaults to ``100``.
        update_after (int, optional): Number of env interactions to collect before
            starting to do gradient descent updates. Ensures replay buffer
            is full enough for useful updates. Defaults to ``1000``.
        steps_per_update (int, optional): Number of gradient descent steps that are
            performed for each gradient descent update. NOTE: This determins the
            ratio of env steps to gradient steps. Defaults to ``100`` which is
            equivalent to a env_step/grad_step ratio of 1.
        num_test_episodes (int, optional): Number of episodes used to test the
            deterministic policy at the end of each epoch. This is used for logging
            the performance. Defaults to ``10``.
        alpha (float, optional): Entropy regularization coefficient (Equivalent to
            inverse of reward scale in the original SAC paper). Defaults to
            ``0.99``.
        alpha3 (float, optional): The Lyapunov constraint error boundary. Defaults
            to ``0.2``.
        labda (float, optional): The Lyapunov lagrance multiplier. Defaults to
            ``0.99``.
        gamma (float, optional): Discount factor. (Always between 0 and 1.).
            Defaults to ``0.9``.
        polyak (float, optional): Interpolation factor in polyak averaging for
            target networks. Target networks are updated towards main networks
            according to:

            .. math:: \\theta_{\\text{targ}} \\leftarrow
                \\rho \\theta_{\\text{targ}} + (1-\\rho) \\theta

            where :math:`\\rho` is polyak. (Always between 0 and 1, usually
            close to 1.). Defaults to ``0.995``.
        target_entropy (float, optional): Initial target entropy used while learning
            the entropy temperature (alpha). Defaults to the
            maximum information (bits) contained in action space. This can be
            calculated according to :

            .. math::
                -{\\prod }_{i=0}^{n}action\\_di{m}_{i}\\phantom{\\rule{0ex}{0ex}}
        adaptive_temperature (bool, optional): Enabled Automating Entropy Adjustment
            for maximum Entropy RL_learning.
        lr_a (float, optional): Learning rate used for the actor. Defaults to
            ``1e-4``.
        lr_c (float, optional): Learning rate used for the (lyapunov) critic. Defaults
            to ``1e-4``.
        lr_a_final(float, optional): The final actor learning rate that is achieved
            at the end of the training. Defaults to ``1e-10``.
        lr_c_final(float, optional): The final critic learning rate that is achieved
            at the end of the training. Defaults to ``1e-10``.
        lr_decay_type (str, optional): The learning rate decay type that is used (
            options are: ``linear`` and ``exponential`` and ``constant``). Defaults to
            ``linear``.
        batch_size (int, optional): Minibatch size for SGD. Defaults to ``256``.
        replay_size (int, optional): Maximum length of replay buffer. Defaults to
            ``1e6``.
        seed (int): Seed for random number generators. Defaults to ``None``.
        device (str, optional): The device the networks are placed on (cpu or gpu).
            Defaults to "cpu".
        logger_kwargs (dict, optional): Keyword args for EpochLogger.
        save_freq (int, optional): How often (in terms of gap between epochs) to save
            the current policy and value function.
        start_policy (str): Path of a already trained policy to use as the starting
            point for the training. By default a new policy is created.
    """
    validate_args(**locals())

    logger_kwargs["verbose_vars"] = (
        STD_OUT_LOG_VARS_DEFAULT
        if logger_kwargs["verbose_vars"] is None
        else logger_kwargs["verbose_vars"]
    )  # NOTE (rickstaa): Done to ensure the std_out doesn't get cluttered.
    logger = EpochLogger(**logger_kwargs)
    logger.save_config(locals())  # Write hyperparameters to logger

    # Create environments
    env, test_env = env_fn(), env_fn()
    obs_dim = env.observation_space.shape
    act_dim = env.action_space.shape[0]
    rew_dim = (
        env.reward_range.shape[0] if isinstance(env.reward_range, gym.spaces.Box) else 1
    )

    # Get default actor critic if no 'actor_critic' was supplied
    if actor_critic is None:
        actor_critic = LyapunovActorCritic if use_lyapunov else SoftActorCritic

    # Set random seed for reproducible results
    # https://pytorch.org/docs/stable/notes/randomness.html
    if seed is not None:
        os.environ["PYTHONHASHSEED"] = str(seed)
        torch.manual_seed(seed)
        np.random.seed(seed)
        random.seed(seed)
        env.seed(seed)
        test_env.seed(seed)

    policy = LAC(
        env,
        actor_critic,
        ac_kwargs,
        use_lyapunov,
        opt_type,
        alpha,
        alpha3,
        labda,
        gamma,
        polyak,
        target_entropy,
        adaptive_temperature,
        lr_a,
        lr_c,
        device,
    )

    # Restore policy if supplied
    if start_policy is not None:
        print(
            colorize(f"INFO: Restoring model from '{start_policy}'.", "cyan", bold=True)
        )
        try:
            policy.restore(start_policy)
            print(colorize("INFO: Model successfully restored.", "cyan", bold=True))
        except Exception as e:
            print(
                colorize(
                    (
                        "ERROR: Shutting down training since {}.".format(
                            e.args[0].lower().rstrip(".")
                        )
                    ),
                    "red",
                    bold=True,
                )
            )
            sys.exit(0)

    replay_buffer = ReplayBuffer(
        obs_dim=obs_dim, act_dim=act_dim, rew_dim=rew_dim, size=replay_size
    )

    # Count variables and print network structure
    var_counts = tuple(
        count_vars(module)
        for module in (
            [policy.ac.pi, policy.ac.L]
            if use_lyapunov
            else [policy.ac.pi, policy.ac.Q1, policy.ac.Q2]
        )
    )
    if use_lyapunov:
        logger.log("\nNumber of parameters: \t pi: %d, \t L: %d\n" % var_counts)
    else:
        logger.log(
            "\nNumber of parameters: \t pi: %d, \t Q1: %d, \t Q2: %d\n" % var_counts
        )
    logger.log("Network structure:\n")
    print(policy.ac, end="\n\n")

    # Create learning rate schedulers
    opt_schedulers = []
    pi_opt_scheduler = get_lr_scheduler(
        policy._pi_optimizer, lr_decay_type, lr_a, lr_a_final, epochs
    )
    opt_schedulers.append(pi_opt_scheduler)
    alpha_opt_scheduler = get_lr_scheduler(
        policy._log_alpha_optimizer, lr_decay_type, lr_a, lr_a_final, epochs
    )
    opt_schedulers.append(alpha_opt_scheduler)
    c_opt_scheduler = get_lr_scheduler(
        policy._c_optimizer, lr_decay_type, lr_c, lr_c_final, epochs
    )
    opt_schedulers.append(c_opt_scheduler)
    if use_lyapunov:
        labda_opt_scheduler = get_lr_scheduler(
            policy._log_labda_optimizer, lr_decay_type, lr_a, lr_a_final, epochs
        )
        opt_schedulers.append(labda_opt_scheduler)

    # Set up model saving
    logger.setup_pytorch_saver(policy)

    # Store initial learning rates
    if logger_kwargs["use_tensorboard"]:
        logger.add_scalar(
            "LearningRates/Lr_a", policy._pi_optimizer.param_groups[0]["lr"], 0
        )
        logger.add_scalar(
            "LearningRates/Lr_c", policy._c_optimizer.param_groups[0]["lr"], 0
        )
        logger.add_scalar(
            "LearningRates/Lr_alpha",
            policy._log_alpha_optimizer.param_groups[0]["lr"],
            0,
        )
        if use_lyapunov:
            logger.add_scalar(
                "LearningRates/Lr_labda",
                policy._log_labda_optimizer.param_groups[0]["lr"],
                0,
            )

    # Main loop: collect experience in env and update/log each epoch
    total_steps = steps_per_epoch * epochs
    start_time = time.time()
    o, ep_ret, ep_len = env.reset(), 0, 0
    for t in range(total_steps):

        # Until start_steps have elapsed, randomly sample actions
        # from a uniform distribution for better exploration. Afterwards,
        # use the learned policy.
        if t > start_steps:
            a = policy.get_action(o)
        else:
            a = env.action_space.sample()

        # Take step in the env
        o_, r, d, _ = env.step(a)
        ep_ret += r
        ep_len += 1

        # Ignore the "done" signal if it comes from hitting the time
        # horizon (that is, when it's an artificial terminal signal
        # that isn't based on the agent's state)
        d = False if ep_len == max_ep_len else d

        replay_buffer.store(o, a, r, o_, d)

        # Make sure to update most recent observation!
        o = o_

        # End of trajectory handling
        if d or (ep_len == max_ep_len):
            logger.store(EpRet=ep_ret, EpLen=ep_len)
            o, ep_ret, ep_len = env.reset(), 0, 0

        # Update handling
        if (t + 1) >= update_after and ((t + 1) - update_after) % update_every == 0:
            for _ in range(steps_per_update):
                batch = replay_buffer.sample_batch(batch_size)
                update_diagnostics = policy.update(data=batch)
                logger.store(**update_diagnostics)  # Log diagnostics

        # End of epoch handling (Save model, test performance and log data)
        if (t + 1) % steps_per_epoch == 0:
            epoch = (t + 1) // steps_per_epoch

            # Save model
            if (epoch % save_freq == 0) or (epoch == epochs):
                logger.save_state({"env": env}, None, epoch=epoch)

            # Test the performance of the deterministic version of the agent
            eps_ret, eps_len = test_agent(
                policy, test_env, num_test_episodes, max_ep_len=max_ep_len
            )
            logger.store(
                TestEpRet=eps_ret, TestEpLen=eps_len, extend=True,
            )

            # Decay learning rates
            for scheduler in opt_schedulers:
                scheduler.step()

            # Log info about epoch
            logger.log_tabular("Epoch", epoch)
            logger.log_tabular("TotalEnvInteracts", t)
            logger.log_tabular("EpRet", with_min_and_max=True)
            logger.log_tabular("TestEpRet", with_min_and_max=True)
            logger.log_tabular("EpLen", average_only=True)
            logger.log_tabular("TestEpLen", average_only=True)
            logger.log_tabular("Lr_a", policy._pi_optimizer.param_groups[0]["lr"])
            logger.log_tabular("Lr_c", policy._c_optimizer.param_groups[0]["lr"])
            logger.log_tabular(
                "Lr_alpha", policy._log_alpha_optimizer.param_groups[0]["lr"]
            )
            if use_lyapunov:
                logger.log_tabular(
                    "Lr_labda", policy._log_labda_optimizer.param_groups[0]["lr"]
                )
            logger.log_tabular("Alpha", average_only=True)
            if use_lyapunov:
                logger.log_tabular("Lambda", average_only=True)
            logger.log_tabular("LossPi", average_only=True)
            if use_lyapunov:
                logger.log_tabular("ErrorL", average_only=True)
            else:
                logger.log_tabular("LossQ", average_only=True)
            if adaptive_temperature:
                logger.log_tabular(
                    "LossAlpha", average_only=True,
                )
            if use_lyapunov:
                logger.log_tabular(
                    "LossLambda", average_only=True,
                )
            if use_lyapunov:
                logger.log_tabular("LVals", with_min_and_max=True)
            else:
                logger.log_tabular("Q1Vals", with_min_and_max=True)
                logger.log_tabular("Q2Vals", with_min_and_max=True)
            logger.log_tabular("LogPi", with_min_and_max=True)
            logger.log_tabular("Entropy", average_only=True)
            logger.log_tabular("Time", time.time() - start_time)
            logger.dump_tabular()

    # Print final message
    print(
        colorize(
            "{}Training finished after {}s".format(
                "\n" if logger_kwargs["verbose"] else "\n\n", time.time() - start_time
            ),
            "cyan",
            bold=True,
        )
    )


if __name__ == "__main__":

    # Import gym environments
    import machine_learning_control.simzoo.simzoo.envs  # noqa: F401

    # Parse algorithm arguments
    parser = argparse.ArgumentParser(
        description="Trains a LAC agent in a given environment."
    )
    parser.add_argument(
        "--env",
        type=str,
        default="Oscillator-v1",
        help="the gym env (default: Oscillator-v1)",
    )  # EX3 env
    parser.add_argument(
        "--hid_a",
        type=int,
        default=64,
        help="hidden layer size of the actor (default: 64)",
    )
    parser.add_argument(
        "--hid_c",
        type=int,
        default=128,
        help="hidden layer size of the lyapunov critic (default: 128)",
    )
    parser.add_argument(
        "--l_a",
        type=int,
        default=2,
        help="number of hidden layer in the actor (default: 2)",
    )
    parser.add_argument(
        "--l_c",
        type=int,
        default=2,
        help="number of hidden layer in the critic (default: 2)",
    )
    parser.add_argument(
        "--act_a",
        type=str,
        default="nn.ReLU",
        help="the hidden layer activation function of the actor (default: nn.ReLU)",
    )
    parser.add_argument(
        "--act_c",
        type=str,
        default="nn.ReLU",
        help="the hidden layer activation function of the critic (default: nn.ReLU)",
    )
    parser.add_argument(
        "--act_out_a",
        type=str,
        default="nn.ReLU",
        help="the output activation function of the actor (default: nn.ReLU)",
    )
    parser.add_argument(
        "--act_out_c",
        type=str,
        default="nn.Identity",
        help="the output activation function of the critic (default: nn.Identity)",
    )
    parser.add_argument(
        "--use_lyapunov",
        type=bool,
        default=True,
        help="lyapunov toggle boolean (default: True)",
    )
    parser.add_argument(
        "--opt_type",
        type=str,
        default="minimize",
        help="algorithm optimization type (default: minimize)",
    )
    parser.add_argument(
        "--max_ep_len",
        type=int,
        default=500,
        help="maximum episode length (default: minimize)",
    )
    parser.add_argument(
        "--epochs", type=int, default=2, help="the number of epochs (default: 50)"
    )
    parser.add_argument(
        "--steps_per_epoch",
        type=int,
        default=2048,
        help="the number of steps per epoch (default: 2048)",
    )
    parser.add_argument(
        "--start_steps",
        type=int,
        default=0,
        help="the number of random exploration steps (default: 0)",
    )
    parser.add_argument(
        "--update_every",
        type=int,
        default=100,
        help="the number of steps for each SGD update (default: 100)",
    )
    parser.add_argument(
        "--update_after",
        type=int,
        default=1000,
        help="the number of steps before starting the SGD (default: 1000)",
    )
    parser.add_argument(
        "--steps_per_update",
        type=int,
        default=100,
        help=(
            "the number of gradient descent steps that are"
            "performed for each SGD update (default: 100)"
        ),
    )
    parser.add_argument(
        "--num_test_episodes",
        type=int,
        default=10,
        help="the number of episodes for the performance analysis (default: 10)",
    )
    parser.add_argument(
        "--alpha",
        type=float,
        default=0.99,
        help="the entropy regularization coefficient (default: 0.99)",
    )
    parser.add_argument(
        "--alpha3",
        type=float,
        default=0.2,
        help="the Lyapunov constraint error boundary (default: 0.2)",
    )
    parser.add_argument(
        "--labda",
        type=float,
        default=0.99,
        help="the Lyapunov lagrance multiplier (default: 0.99)",
    )
    parser.add_argument(
        "--gamma", type=float, default=0.995, help="discount factor (default: 0.995)"
    )
    parser.add_argument(
        "--polyak",
        type=float,
        default=0.995,
        help="the interpolation factor in polyak averaging (default: 0.995)",
    )
    parser.add_argument(
        "--target_entropy",
        type=float,
        default=None,
        help="the initial target entropy (default: -action_space)",
    )
    parser.add_argument(
        "--adaptive_temperature",
        type=bool,
        default=True,
        help="the boolean for enabling automating Entropy Adjustment (default: True)",
    )
    parser.add_argument(
        "--lr_a", type=float, default=1e-4, help="actor learning rate (default: 1e-4)"
    )
    parser.add_argument(
        "--lr_c", type=float, default=3e-4, help="critic learning rate (default: 1e-4)"
    )
    parser.add_argument(
        "--lr_a_final",
        type=float,
        default=1e-10,
        help="the finalactor learning rate (default: 1e-10)",
    )
    parser.add_argument(
        "--lr_c_final",
        type=float,
        default=1e-10,
        help="the finalcritic learning rate (default: 1e-10)",
    )
    parser.add_argument(
        "--lr_decay_type",
        type=str,
        default="linear",
        help="the learning rate decay type (default: 1e-10)",
    )
    parser.add_argument(
        "--batch-size",
        type=float,
        default=256,
        help="mini batch size of the SGD (default: 256)",
    )
    parser.add_argument(
        "--replay-size",
        type=int,
        default=int(1e6),
        help="replay buffer size (default: 1e6)",
    )
    parser.add_argument(
        "--seed", "-s", type=int, default=0, help="the random seed (default: 0)"
    )
    parser.add_argument(
        "--save_freq",
        type=int,
        default=1,
        help="how often (in epochs) the policy should be saved (default: 1)",
    )
    parser.add_argument(
        "--device",
        type=str,
        default="cpu",
        help="The device the networks are placed on (default: cpu)",
    )
    parser.add_argument(
        "--start_policy",
        type=str,
        default=None,
        help=(
            "The policy which you want to use as the starting point for the training"
            " (default: None)"
        ),
    )

    # Parse logger related arguments
    parser.add_argument(
        "--exp_name",
        type=str,
        default="lac",
        help="the name of the experiment (default: sac)",
    )
    parser.add_argument(
        "--verbose",
        "-v",
        type=bool,
        default=True,
        help="log diagnostics to std out (default: True)",
    )
    parser.add_argument(
        "--verbose_fmt",
        type=str,
        default="line",
        help=(
            "log diagnostics std out format (options: 'table' or 'line', default: "
            "line)"
        ),
    )
    parser.add_argument(
        "--verbose_vars",
        nargs="+",
        default=STD_OUT_LOG_VARS_DEFAULT,
        help=("a space seperated list of the values you want to show on the std out."),
    )
    parser.add_argument(
        "--save_checkpoints",
        type=bool,
        default=False,
        help="use model checkpoints (default: False)",
    )
    parser.add_argument(
        "--use_tensorboard",
        type=bool,
        default=False,
        help="use tensorboard (default: False)",
    )
    args = parser.parse_args()

    # Setup actor critic arguments
    actor_critic = LyapunovActorCritic if args.use_lyapunov else SoftActorCritic
    output_activation = {}
    output_activation["actor"] = safe_eval(args.act_out_a)
    if not args.use_lyapunov:
        output_activation["critic"] = safe_eval(args.act_out_c)
    ac_kwargs = dict(
        hidden_sizes={
            "actor": [args.hid_a] * args.l_a,
            "critic": [args.hid_c] * args.l_c,
        },
        activation={"actor": safe_eval(args.act_a), "critic": safe_eval(args.act_c)},
        output_activation=output_activation,
    )

    # Setup output dir for logger and return output kwargs
    logger_kwargs = setup_logger_kwargs(
        args.exp_name,
        args.seed,
        save_checkpoints=args.save_checkpoints,
        use_tensorboard=args.use_tensorboard,
        verbose=args.verbose,
        verbose_fmt=args.verbose_fmt,
        verbose_vars=args.verbose_vars,
    )
    logger_kwargs["output_dir"] = osp.abspath(
        osp.join(
            osp.dirname(osp.realpath(__file__)),
            f"../../../../../data/lac/{args.env.lower()}/runs/run_{int(time.time())}",
        )
    )
    torch.set_num_threads(torch.get_num_threads())

    lac(
        lambda: gym.make(args.env, reference_type="periodic"),
        actor_critic=actor_critic,
        ac_kwargs=ac_kwargs,
        use_lyapunov=args.use_lyapunov,
        opt_type=args.opt_type,
        max_ep_len=args.max_ep_len,
        epochs=args.epochs,
        steps_per_epoch=args.steps_per_epoch,
        start_steps=args.start_steps,
        update_every=args.update_every,
        update_after=args.update_after,
        steps_per_update=args.steps_per_update,
        num_test_episodes=args.num_test_episodes,
        alpha=args.alpha,
        alpha3=args.alpha3,
        labda=args.labda,
        gamma=args.gamma,
        polyak=args.polyak,
        target_entropy=args.target_entropy,
        adaptive_temperature=args.adaptive_temperature,
        lr_a=args.lr_a,
        lr_c=args.lr_c,
        lr_a_final=args.lr_a_final,
        lr_c_final=args.lr_c_final,
        lr_decay_type=args.lr_decay_type,
        batch_size=args.batch_size,
        replay_size=args.replay_size,
        seed=args.seed,
        save_freq=args.save_freq,
        device=args.device,
        start_policy=args.start_policy,
        logger_kwargs=logger_kwargs,
    )
